# impure
[目的]
「俺言語」(im)pureを作る

[手段]
・字句/構文解析にはpython plyを使う(面倒なことはしない)
・python llvmliteを持ちいて、最終的に(jit)コンパイラにする

[実行方法]
・python3(pypy3が良)環境、rlwrap
・必要ライブラリはPLY、termcolor、(最終的に)llvmlite
・該当ディレクトリ内で./pureでreplが起動する

[できていないこと]
・llvm対応がまったくの未
  ※現時点ではSECD風中間言語にコンパイルし、Pythonで作ったSECD マシンで解釈実行している(したがってとっても遅い！pypy実行が良とした理由)
・クラス対応がこれから
・例外処理未対応

[pure言語の仕様]
・関数型言語。命令はすべて「式」である。式は値を持つ
・基本データ型はNone(値なし)、整数、長整数、浮動小数、真理値、関数(クロージャ)、ポート、文字列、ベクタ、辞書、クラス

[プログラム例]
    (1)フィボナッチ関数
    fib = lambda(n) (f = lambda(i, a, b) if i == 0: b: f(i -- , a + b, a))(n, 1, 0)
    fib(100) -> 
    代入式    ：[書式] 式1 = 式2                    [意味]　式2を実行し、式1を実行した結果のデータに代入する
    関数呼出  ：[書式] 式1(式2,式3, …)             [意味]  式2, 式3…を実引数として式1を実行した結果の関数を実行する
    lambda式  ：[書式] lambda (ID1, ID2, …) 式3    [意味]　ID1,ID2…を仮引数とする関数を生成し、生成した関数を値として返す
    if    式  ：[書式] if 式1 : 式2 : 式3           [意味]　式1を実行し結果が真なら式2を実行する。そうでないなら式3を実行する
    比較演算  ：[書式] 式1 == 式2                   [意味] 式1,式2を実行しそれぞれの結果が等しければ真をそうでないなら偽を返す
    減算演算  ：[書式] 式--                         [意味] 式-1と同じ

    (2)ベクタの内容を加算する
    sum = lambda(vect) {s = 0; i = 0; N = len(vec); while i<N: { s += vec[i]; i++};s}
    ※別定義 sum = lambda(vect) (f=lambda(i,s) if i==0: s: f(i--, s+=vect[i]))(len(vect)--,0)
    sum([1, 2, 3, 4])  -> 10
    複式      ：[書式] {式1,式2…}                  [意味] 式1,式2,…を実行し、最後の式の実行結果を返す
    len関数   ：[書式] len(式)                      [意味] 式を実行しその結果(ベクタか文字列)の長さを返す
    while式   ：[書式] while 式1 : 式2              [意味] 式1を実行し真なら式2を実行するを繰り返す。式1が偽ならNoneを返す
    加算代入  ：[書式] 式1 +=式2                    [意味] 式1 = 式1 + 式2　と同じ
    ベクタ参照：[書式]
    (3)多引数の加算関数を作る
    add=lambd(vect..) sum(x)
    add(1,2,3,4) ->10
    add([1,2,3,4]..) ->10
    ベクタ化/多値化： ID.. または　式..            [意味] 仮引数の最後に使った場合は、残りの引数をベクタとして最後の仮因数に関連付ける
                                                          実引数の最後に使った場合は、式で表されるベクタの値をばらして引数とする

    (4)テキストファイルを読み込んで文字列にする
    
プログラム		式

式			2項演算式
			前置単項演算式
			後置単項演算式
			if式
			while式
			lambda式
			優先式
			複式

2項演算式		式1 += 式2		加算代入	式2の評価結果を式1の評価結果に代入する
			式1 -= 式2		減算代入	式1 = 式1 + 式2
			式1 *= 式2		乗算代入
			式1 /= 式2		除算代入
			%= :
			//=:
			
前置単項演算式		op expr
			- expr			符号反転
			! expr			2値否定
			!! expr			ビット単位否定
後置単項演算式		expr　++		インクリメント
			expr --			デクリメント
			expr [ expr ]		ベクタ参照
			expr ( expr_list )	関数呼出し

if式			if 式1 : 式2 : 式3				式1の評価結果が真なら式2を評価しその値を返す。式3は評価しない
			if 式1 : 式2 


while式			while 式1 : 式2		

lambda式		lambda ( ) 式
			lambda ( 式リスト ) 式
			lambda (
複式

優先式

ベクタ化/多値化

expr		:　式
expr_list	: 式1, 式2, 式3…
