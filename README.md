# impure
<<目的>>
「俺言語」pureを作る

<<手段>>
字句/構文解析にはpython plyを使う
python llvmliteを持ちいて、最終的に(jit)コンパイラにする

<<実行方法>>
python3(pypy3が良)環境、rlwrap
必要ライブラリはPLY、termcolor、(最終的に)llvmlite
./pureでreplが起動する

<<できていないこと>>
・llvm対応がまったくの未
    現時点ではSECD風中間言語にコンパイルし、Pythonで作ったSECD マシンで解釈実行している(したがってとっても遅い！pypy実行が良とした理由)
・クラス対応がこれから
・例外処理未対応

<<pure言語の仕様>>
・関数型言語。命令はすべて「式」である。式は値を持つ
・基本データ型はNone(値なし)、整数、長整数、浮動小数、真理値、関数(クロージャ)、ポート、文字列、ベクタ、辞書、クラス

<<プログラム例>>
    (1)フィボナッチ関数
    fib = lambda(n) (f = lambda(i, a, b) if i == 0: b: f(i -- , a + b, a))(n, 1, 0)
    fib(100) -> 
    代入式  ：[書式] 式1 = 式2                    [意味]　式2を実行し、式1を実行した結果のデータに代入する
    関数呼出：[書式] 式1(式2,式3, …)             [意味]  式2, 式3…を実引数として式1を実行した結果の関数を実行する
    lambda式：[書式] lambda (ID1, ID2, …) 式3    [意味]　ID1,ID2…を仮引数とする関数を生成し、生成した関数を値として返す
    if    式：[書式] if 式1 : 式2 : 式3           [意味]　式1を実行し結果が真なら式2を実行する。そうでないなら式3を実行する
    比較演算：[書式] 式1 == 式2                   [意味] 式1,式2を実行しそれぞれの結果が等しければ真をそうでないなら偽を返す
    減算演算：[書式] 式--                         [意味] 式-1と同じ

    (2)ベクタの内容を加算する
    sum = lambda(vect) {s = 0; i = 0; N = len(vec); while i<N: { s += vec[i]; i++};s}
    ※別定義 sum = lambda(vect) (f=lambda(i,s) if i==0: s: f(i--, s+=vect[i]))(len(vect)--,0)
    sum([1, 2, 3, 4])  -> 10
    複式    ：[書式] {式1,式2…}                  [意味] 式1,式2,…を実行し、最後の式の実行結果を返す
    len関数 ：[書式] len(式)                      [意味] 式を実行しその結果(ベクタか文字列)の長さを返す
    while式 ：[書式] while 式1 : 式2              [意味] 式1を実行し真なら式2を実行するを繰り返す。式1が偽ならNoneを返す
    加算代入：[書式] 式1 +=式2                    [意味] 式1 = 式1 + 式2　と同じ

    (3)多引数の加算関数を作る
    add=lambd(vect..) sum(x)
    add(1,2,3,4) ->10
    add([1,2,3,4]..) ->10
    ベクタ化/多値化： ID.. または　式..            [意味] 仮引数の最後に使った場合は、残りの引数をベクタとして最後の仮因数に関連付ける
                                                          実引数の最後に使った場合は、式で表されるベクタの値をばらして引数とする

    (4)テキストファイルを読み込んで文字列にする
